## 基本介绍 ##

在go语言中，两个最具特点的地方：**接口**和**并发**,本篇就接着之前的函数和方法说下go的接口；go语言的接口是非入侵式的，这也是最具创新的地方，所以要想实现一个接口只要显示啦其所有方法，而不用添加任何标记。

接口是方法声明的集合，方法声明由方法名称和方法签名构成，而且在一个接口内不允许声明同名的方法（也就是不支持所谓的重载）。接口也属于类型，所有它的声明方式和自定义数据类型的声明差不多：

	type Closer interface {
		Close() error
	}
	
而且，接口还支持嵌套，我们可以把若干接口类型嵌套到另一个接口类型中，但是接口不能通过直接嵌入和间接嵌入的方式嵌入自身。

	type ReadWriter interface {
		Reader
		Writer
	}
	
接口内的方法和嵌入接口的方法不会发生覆盖，而是不能通过编译；go语言中存在一个空接口interface{}，空接口中不包含任何方法声明，所有go语言中所有数据类型都实现了空接口。

## 属性和操作

接口中的方法集合是接口中的最基本属性；任何的自定义的数据类型，只要它的方法集中包含了某一接口的所有方法，那么它就实现了该接口；当然和其他语言一样，一个数据类型可以实现多个接口。

方法体内对接收者的修改不会影响到它的源值，因为修改的只是**接收者的副本**！

	type Interface interface {
		Swap()
	}

	type Nums [2]int

	func (n Nums) Swap() {
		n[0], n[1] = n[1], n[0]
	}

为了到达交换数组的值的目的，我们可以把别名类型改为切片的；此时虽然操作的是切片的副本，但是它同样的改变了底层数组！

	type Interface interface {
		Swap()
	}

	type Nums []int

	func (n Nums) Swap() {
		n[0], n[1] = n[1], n[0]
	}
	
虽然说法不准确，但是我们姑且认为从数组类型修改为切片类型，是从值类型向指针类型的转换，当接收者是指针类型时，方法对接收者的修改会改变它的源值。
所以，以上方法可以修改为：

	type Interface interface {
		Swap()
	}

	type Nums [2]int

	func (n *Nums) Swap() {
		n[0], n[1] = n[1], n[0]
	}

当我们把函数的接收者改为对应的指针类型，那么原类型就不是接口类型的实现了，但是此时Nums类型不再是Interface的实现了，而Nums类型的值对应的指针值才是接口的实现。